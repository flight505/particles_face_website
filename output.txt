
===== Filename: src/js/components/scene.js =====

// Importing necessary modules and libraries
import {
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  BufferGeometry,
  BufferAttribute,
  Points,
  ShaderMaterial,
  Raycaster,
  Vector2,
  AdditiveBlending,
  PointLight,
  Frustum,
  Matrix4,
  RepeatWrapping, // Imported RepeatWrapping
} from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import Stats from 'stats-js'
import LoaderManager from '@/js/managers/LoaderManager'
import vertexShader from '@/js/glsl/main.vert'
import fragmentShader from '@/js/glsl/main.frag'
import { randFloat } from 'three/src/math/MathUtils'
import gsap from 'gsap'
import TouchTexture from './TouchTexture'
import { isTouch } from '@/js/utils/isTouch'
import {
  BloomEffect,
  ChromaticAberrationEffect,
  EffectComposer,
  RenderPass,
  EffectPass,
  BlendFunction,
  SMAAEffect,
  GlitchEffect,
  VignetteEffect,
  NoiseEffect,
  GlitchMode,
} from 'postprocessing'

export default class MainScene {
  canvas
  renderer
  scene
  camera
  controls
  stats
  width
  height
  mouse = new Vector2(0, 0)
  currentFrameIndex = 0
  glitchEffect
  frustum
  projScreenMatrix
  directionSpriteMap = {}
  currentDirection = 'front'
  spriteSheets = {}
  framesPerDirection = 30

  constructor() {
    this.canvas = document.querySelector('.scene')
    if (!this.canvas) {
      throw new Error('Canvas element with class "scene" not found')
    }
    this.width = window.innerWidth
    this.height = window.innerHeight
    this.touch = new TouchTexture()
    this.frustum = new Frustum()
    this.projScreenMatrix = new Matrix4()
    this.init().catch(error => {
      console.error('Initialization failed:', error)
    })
  }

  init = async () => {
    try {
      const assets = [
        { name: 'front_up', texture: './img/front_up_sprite_sheet.png', flipY: true },
        { name: 'front_up_left', texture: './img/front_up_left_sprite_sheet.png', flipY: true },
        { name: 'front_side_left', texture: './img/front_side_left_sprite_sheet.png', flipY: true },
        { name: 'front_down_left', texture: './img/front_down_left_sprite_sheet.png', flipY: true },
        { name: 'front_down', texture: './img/front_down_sprite_sheet.png', flipY: true },
        { name: 'front_down_right', texture: './img/front_down_right_sprite_sheet.png', flipY: true },
        { name: 'front_side_right', texture: './img/front_side_right_sprite_sheet.png', flipY: true },
        { name: 'front_up_right', texture: './img/front_up_right_sprite_sheet.png', flipY: true },
      ]

      await LoaderManager.load(assets)
      console.log('Loaded Textures:', LoaderManager.assets)

      this.initializeUniforms(); // Move this line up
      this.setupDirectionSpriteMap();

      this.setScene();
      this.setRenderer();
      this.setCamera();

      this.setParticlesGrid()
      this.setStats()
      this.setControls()
      this.setRaycaster()
      this.setPostProcessing()
      this.setLights()
      this.handleResize()

      this.events()
      this.animateIn()

      // Start the animation loop after initialization
      this.draw(0)
    } catch (error) {
      console.error('Error during initialization:', error)
      throw error
    }
  }

  setupDirectionSpriteMap() {
    // Helper function to safely get the texture
    const getTexture = (name) => {
      const asset = LoaderManager.assets[name];
      if (!asset) {
        console.warn(`Asset ${name} not found`);
        return null;
      }
      return asset.texture || asset; // Return texture if it's nested, or the asset itself if it's directly a texture
    };

    this.directionSpriteMap = {
      'front_up': getTexture('front_up'),
      'front_up_left': getTexture('front_up_left'),
      'front_side_left': getTexture('front_side_left'),
      'front_down_left': getTexture('front_down_left'),
      'front_down': getTexture('front_down'),
      'front_down_right': getTexture('front_down_right'),
      'front_side_right': getTexture('front_side_right'),
      'front_up_right': getTexture('front_up_right'),
      'front': getTexture('front_up'), // Assuming 'front_up' serves as 'front'
    };

    // Log the directionSpriteMap to verify its contents
    console.log('Direction Sprite Map:', this.directionSpriteMap);

    // Ensure all sprite sheets have the same properties
    for (let key in this.directionSpriteMap) {
      if (this.directionSpriteMap[key]) {
        this.directionSpriteMap[key].wrapS = RepeatWrapping;
        this.directionSpriteMap[key].wrapT = RepeatWrapping;
        this.directionSpriteMap[key].repeat.set(1 / 6, 1 / 5); // 6 columns, 5 rows
      } else {
        console.warn(`Sprite sheet for direction "${key}" is missing.`);
      }
    }

    // Set initial sprite sheet
    const initialDirection = 'front';
    const initialSpriteSheet = this.directionSpriteMap[initialDirection] || Object.values(this.directionSpriteMap).find(texture => texture);

    if (initialSpriteSheet) {
      if (this.uniforms && this.uniforms.uSpriteSheet) {
        this.uniforms.uSpriteSheet.value = initialSpriteSheet;
      } else {
        console.warn('uniforms or uSpriteSheet not initialized yet');
      }
    } else {
      console.error('No valid sprite sheet found for initialization');
    }
  }

  setRenderer() {
    try {
      this.renderer = new WebGLRenderer({
        canvas: this.canvas,
        antialias: true,
        alpha: true,
      })
      this.renderer.setSize(this.width, this.height)
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
      this.renderer.setClearColor(0x000000, 0)
      this.renderer.domElement.style.position = 'fixed'
      this.renderer.domElement.style.top = '0'
      this.renderer.domElement.style.left = '0'
      this.renderer.domElement.style.zIndex = '1'
    } catch (error) {
      console.error('Error setting up WebGL renderer:', error)
      throw error
    }
  }

  setScene() {
    this.scene = new Scene()
  }

  setCamera() {
    const aspectRatio = this.width / this.height
    const fieldOfView = 60
    const nearPlane = 0.1
    const farPlane = 10000

    this.camera = new PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane)
    this.camera.position.set(0, 0, 220)
    this.camera.lookAt(0, 0, 0)

    this.scene.add(this.camera)
  }

  setControls() {
    try {
      this.controls = new OrbitControls(this.camera, this.renderer.domElement)
      this.controls.enableDamping = true
      this.controls.enableRotate = true
      this.controls.enableZoom = true
    } catch (error) {
      console.error('Error setting up OrbitControls:', error)
      this.controls = null
    }
  }

  setParticlesGrid() {
    try {
      const geometry = new BufferGeometry()
      const { particles, initPositions, randoms, colorRandoms } = this.generateParticleAttributes()
      this.setGeometryAttributes(geometry, particles, initPositions, randoms, colorRandoms)
      this.initializeUniforms()
      this.updateFrameOffset(this.currentDirection, this.currentFrameIndex)
      this.createParticleMesh(geometry)

      // Initialize visibility attribute
      const visibilityArray = new Float32Array(particles.length / 3)
      visibilityArray.fill(1.0)
      geometry.setAttribute('visibility', new BufferAttribute(visibilityArray, 1))
    } catch (error) {
      console.error('Error setting up particle grid:', error)
      throw error
    }
  }

  generateParticleAttributes() {
    const particles = []
    const initPositions = []
    const randoms = []
    const colorRandoms = []
    const multiplier = 12 // Adjust the multiplier for more particles
    this.nbColumns = 18 * multiplier
    this.nbLines = 32 * multiplier

    const halfColumn = this.nbColumns / 2
    const halfLines = this.nbLines / 2

    for (let i = 0; i < this.nbLines; i++) {
      for (let j = 0; j < this.nbColumns; j++) {
        const x = i - halfLines
        const y = j - halfColumn
        const z = 0
        particles.push(x, y, z)

        initPositions.push(
          x + randFloat(-50, 50),
          y + randFloat(-50, 50),
          randFloat(-100, 100)
        )
        randoms.push(Math.random())
        colorRandoms.push(Math.random())
      }
    }

    return {
      particles: new Float32Array(particles),
      initPositions: new Float32Array(initPositions),
      randoms: new Float32Array(randoms),
      colorRandoms: new Float32Array(colorRandoms),
    }
  }

  setGeometryAttributes(geometry, particles, initPositions, randoms, colorRandoms) {
    geometry.setAttribute('position', new BufferAttribute(particles, 3))
    geometry.setAttribute('initPosition', new BufferAttribute(initPositions, 3))
    geometry.setAttribute('randoms', new BufferAttribute(randoms, 1))
    geometry.setAttribute('colorRandoms', new BufferAttribute(colorRandoms, 1))
    geometry.center()
  }

  initializeUniforms() {
    this.dpr = Math.min(window.devicePixelRatio, 2)
    this.uniforms = {
      uPointSize: { value: 0.2 },
      uNbLines: { value: this.nbLines },
      uNbColumns: { value: this.nbColumns },
      uProgress: { value: 0 },
      uTime: { value: 0.0 },
      uTouch: { value: this.touch.texture },
      uScaleHeightPointSize: { value: (this.dpr * this.height) / 2.0 },
      uFrameIndex: { value: 0.0 }, // Explicitly use 0.0 to ensure it's a float
      uSpriteCols: { value: 6 }, // 6 columns in sprite sheet
      uSpriteRows: { value: 5 }, // 5 rows in sprite sheet
      uSpriteSheet: { value: this.directionSpriteMap['front'] }, // Directly assign texture
      uTexOffset: { value: new Vector2(0, 0) },
      uDisplacementScale: { value: 30.0 },
      uDisplacementBlend: { value: 0.0 },
      uDispersion: { value: 1.0 },
      uDistortionFrequency: { value: 0.1 },
      uDistortionAmplitude: { value: 1.0 },
      uRandomSeed: { value: Math.random() * 100 },
      uResolution: { value: new Vector2(this.width, this.height) },
      uTotalFrames: { value: this.framesPerDirection }, // Add this line

    }
  }

  createParticleMesh(geometry) {
    const customMaterial = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader,
      fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blending: AdditiveBlending,
    })
    this.mesh = new Points(geometry, customMaterial)
    if (this.scene) {
      this.scene.add(this.mesh)
    } else {
      console.error('Scene is not initialized. Cannot add mesh.')
    }
  }

  updateFrameOffset(direction, frameIndex) {
    const actualFrame = Math.floor(frameIndex) % this.framesPerDirection

    // Set the sprite sheet based on direction
    const selectedSpriteSheet = this.directionSpriteMap[direction] || this.directionSpriteMap['front']
    if (!selectedSpriteSheet) {
      console.warn(`Sprite sheet for direction "${direction}" is missing. Falling back to 'front'.`)
      return
    }
    this.uniforms.uSpriteSheet.value = selectedSpriteSheet

    // Calculate Column and Row for Current Frame
    const frameCol = actualFrame % this.uniforms.uSpriteCols.value
    const frameRow = Math.floor(actualFrame / this.uniforms.uSpriteCols.value)

    const uOffset = frameCol / this.uniforms.uSpriteCols.value
    const vOffset = frameRow / this.uniforms.uSpriteRows.value

    this.uniforms.uTexOffset.value.set(uOffset, vOffset)
  }

  handleMouseMove = (event) => {
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1

    // Determine direction based on mouse position
    const direction = this.getDirectionFromMouse(mouseX, mouseY)

    // Update frame index based on horizontal movement
    const deltaX = mouseX - this.mouse.x
    const frameChangeSpeed = 30.0 // Adjusted for smoother transitions

    this.currentFrameIndex += deltaX * frameChangeSpeed
    this.currentFrameIndex = Math.max(0, Math.min(this.currentFrameIndex, this.uniforms.uTotalFrames.value - 1))

    this.mouse.x = mouseX
    this.mouse.y = mouseY

    // Update rotation
    const rotateX = gsap.quickTo(this.mesh.rotation, 'x', { duration: 0.5, ease: 'circ.out' })
    const rotateY = gsap.quickTo(this.mesh.rotation, 'y', { duration: 0.5, ease: 'circ.out' })

    rotateX(-this.mouse.y * Math.PI / 64) // Negate to reverse tilt direction
    rotateY(this.mouse.x * Math.PI / 64)

    // Animate frame index
    gsap.to(this.uniforms.uFrameIndex, {
      value: this.currentFrameIndex,
      duration: 0.3,
      ease: 'power2.out',
      onUpdate: () => {
        this.updateFrameOffset(direction, this.uniforms.uFrameIndex.value)
      },
    })

    // Existing raycaster logic
    this.ray.setFromCamera(this.mouse, this.camera)
    this.intersects = this.ray.intersectObjects([this.mesh])

    if (this.intersects.length) {
      const uv = new Vector2(0.5, 0.5)
      uv.x = (this.intersects[0].point.x / this.nbLines) + 0.5
      uv.y = (this.intersects[0].point.y / this.nbColumns) + 0.5
      this.touch.addTouch(uv)
    }

    if (this.light) {
      this.light.position.x = -this.mouse.x * 10
      this.light.position.y = this.mouse.y * 10
    }
  }

  getDirectionFromMouse(x, y) {
    const threshold = 0.3
    if (y > threshold) { // Upward
      if (x < -threshold) return 'front_up_left'
      if (x > threshold) return 'front_up_right'
      return 'front_up'
    } else if (y < -threshold) { // Downward
      if (x < -threshold) return 'front_down_left'
      if (x > threshold) return 'front_down_right'
      return 'front_down'
    } else { // Neutral vertically
      if (x < -threshold) return 'front_side_left'
      if (x > threshold) return 'front_side_right'
      return 'front'
    }
  }

  animateIn() {
    gsap.fromTo(
      this.uniforms.uProgress,
      { value: 0 },
      {
        value: 1,
        duration: 2.0,
        ease: 'power3.out',
        onUpdate: () => {
          this.uniforms.uDisplacementBlend.value = this.uniforms.uProgress.value
        },
      }
    )

    gsap.fromTo(
      this.uniforms.uDispersion,
      { value: 1 },
      {
        value: 0,
        duration: 2.0,
        ease: 'power3.out',
      }
    )

    // Animate distortion amplitude
    gsap.fromTo(
      this.uniforms.uDistortionAmplitude,
      { value: 0 },
      {
        value: 1.5,
        duration: 2.0,
        ease: 'power2.inOut',
      }
    )

    // Animate distortion frequency
    gsap.fromTo(
      this.uniforms.uDistortionFrequency,
      { value: 0.05 },
      {
        value: 0.2,
        duration: 3.0,
        ease: 'power2.inOut',
        yoyo: true,
        repeat: -1,
      }
    )
  }

  setStats() {
    try {
      this.stats = new Stats()
      this.stats.showPanel(0)
      document.body.appendChild(this.stats.dom)
    } catch (error) {
      console.error('Error setting up stats:', error)
      this.stats = null
    }
  }

  events() {
    window.addEventListener('resize', this.handleResize, { passive: true })
    window.addEventListener('mousemove', this.handleMouseMove, { passive: true })
  }

  handleTouchMove = () => {
    this.ray.setFromCamera(this.mouse, this.camera)
    this.intersects = this.ray.intersectObjects([this.mesh])

    if (this.intersects.length) {
      const uv = new Vector2(0.5, 0.5)
      uv.x = this.intersects[0].point.x / this.nbLines + 0.5
      uv.y = this.intersects[0].point.y / this.nbColumns + 0.5
      this.touch.addTouch(uv)
    }
  }

  setRaycaster() {
    this.ray = new Raycaster()
    this.mouse = new Vector2()

    if (isTouch()) {
      window.addEventListener('touchmove', this.handleTouchMove)
    }
  }

  setPostProcessing() {
    this.composer = new EffectComposer(this.renderer);
    this.renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(this.renderPass);

    // Retro-style bloom effect with reduced intensity
    const bloomEffect = new BloomEffect({
      intensity: 2.5,
      luminanceThreshold: 0.05,
      luminanceSmoothing: 0.7,
      blendFunction: BlendFunction.SCREEN
    });

    // Chromatic aberration effect
    this.chromaticAberrationEffect = new ChromaticAberrationEffect({
      offset: new Vector2(0.004, 0.004),
    });

    // Glitch effect
    this.glitchEffect = new GlitchEffect({
      chromaticAberrationOffset: new Vector2(3, 3),
      delay: new Vector2(1.5, 3.5),
      duration: new Vector2(0.2, 0.4), // Shorter duration for less processing
      strength: new Vector2(0.3, 1.0),
      mode: GlitchMode.CONSTANT_WILD
    });

    // Vignette effect for a classic look
    const vignetteEffect = new VignetteEffect({
      eskil: false,
      offset: 0.2, // Increased offset for a more pronounced vignette
      darkness: 0.4 // Reduced darkness for a softer vignette
    });

    // Noise effect
    const noiseEffect = new NoiseEffect({
      blendFunction: BlendFunction.OVERLAY,
      premultiply: true
    });
    noiseEffect.blendMode.opacity.value = 0.05;

    const smaaEffect = new SMAAEffect();

    // Add effects in separate passes
    this.composer.addPass(new EffectPass(this.camera, bloomEffect));
    this.composer.addPass(new EffectPass(this.camera, this.chromaticAberrationEffect));
    this.composer.addPass(new EffectPass(this.camera, vignetteEffect, noiseEffect, smaaEffect));
    this.composer.addPass(new EffectPass(this.camera, this.glitchEffect));
  }

  setLights() {
    this.light = new PointLight('#ffffff', 1)
    this.light.position.set(0, 0, 100)
    this.scene.add(this.light)
  }

  updateFrustum() {
    this.projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse)
    this.frustum.setFromProjectionMatrix(this.projScreenMatrix)
  }

  updateParticleVisibility() {
    if (!this.mesh) return

    const positions = this.mesh.geometry.attributes.position
    const visibility = this.mesh.geometry.attributes.visibility

    for (let i = 0; i < positions.count; i++) {
      const x = positions.getX(i)
      const y = positions.getY(i)
      const z = positions.getZ(i)

      if (this.frustum.containsPoint({ x, y, z })) {
        visibility.setX(i, 1.0)
      } else {
        visibility.setX(i, 0.0)
      }
    }

    visibility.needsUpdate = true
  }

  draw = (time) => {
    if (this.stats) this.stats.begin()

    if (this.controls) this.controls.update()

    // Update frustum and particle visibility
    this.updateFrustum()
    this.updateParticleVisibility()

    if (this.uniforms && this.uniforms.uTime) {
      this.uniforms.uTime.value = time * 0.001
    } else {
      console.warn('uTime uniform is not defined')
    }

    this.composer.render()

    this.touch.update()

    if (this.stats) this.stats.end()
    this.raf = window.requestAnimationFrame(this.draw)

    // Update random seed periodically for variety in distortion
    if (Math.random() < 0.01) { // Change seed roughly every 100 frames
      this.uniforms.uRandomSeed.value = Math.random() * 100
    }
  }

  handleResize = () => {
    this.width = window.innerWidth
    this.height = window.innerHeight

    this.camera.aspect = this.width / this.height
    this.camera.updateProjectionMatrix()

    this.renderer.setPixelRatio(this.dpr)
    this.renderer.setSize(this.width, this.height)
    this.composer.setSize(this.width, this.height)

    this.uniforms.uScaleHeightPointSize.value = (this.dpr * this.height) / 2
    this.uniforms.uResolution.value.set(this.width, this.height)
  }
}


===== Filename: src/js/glsl/main.frag =====

precision highp float;

// Sprite Sheet Sampler
uniform sampler2D uSpriteSheet;

// Frame Control Uniforms
uniform float uFrameIndex;
uniform float uSpriteCols;
uniform float uSpriteRows;

// Animation Progress
uniform float uProgress;
uniform float uTime;
uniform vec2 uResolution;

// Varying UV Coordinates from Vertex Shader
varying vec2 vTexCoords;

// Varying Alpha from Vertex Shader
varying float vAlpha;

float circle(vec2 uv, float border) {
  float radius = 0.5;
  float dist = radius - distance(uv, vec2(0.5));
  return smoothstep(0.0, border, dist);
}

void main() {
  // Total frames per sprite sheet
  float framesPerSheet = float(uSpriteCols * uSpriteRows);

  // Use uFrameIndex to determine which frame to show
  float frameIndex = floor(uFrameIndex);
  
  // Calculate Column and Row for Current Frame
  float frameCol = mod(frameIndex, uSpriteCols);
  float frameRow = floor(frameIndex / uSpriteCols);
  
  float frameWidth = 1.0 / uSpriteCols;
  float frameHeight = 1.0 / uSpriteRows;

  vec2 frameUVOffset = vec2(frameCol * frameWidth, frameRow * frameHeight);
  
  vec2 finalUV = frameUVOffset + vTexCoords * vec2(frameWidth, frameHeight);
  
  // Sample the sprite sheet
  vec4 sampledColor = texture2D(uSpriteSheet, finalUV);
  
  // Adjust color to create a stronger blue-green tint
  vec3 tintedColor = mix(sampledColor.rgb, vec3(0.0, 0.8, 1.0), 0.2);
  
  // Enhance the pulsating glow effect
  float glow = sin(uTime * 2.0) * 0.5 + 0.5;
  
  // Apply brightness and glow
  vec3 finalColor = tintedColor * (0.5 + glow * 0.5);
  
  // Add a stronger blue halo
  float halo = 1.0 - smoothstep(0.2, 0.5, length(gl_PointCoord - 0.5));
  finalColor += vec3(0.0, 0.6, 1.0) * halo * 0.8;

  // Apply a softer circular mask
  float mask = smoothstep(0.5, 0.4, length(gl_PointCoord - 0.5));

  gl_FragColor = vec4(finalColor, sampledColor.a * mask * uProgress * vAlpha);

  // Slightly brighten the overall image
  gl_FragColor.rgb *= 1.0;

  // Calculate brightness
  float brightness = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));

  // Discard pixels if too transparent or too dark
  if (gl_FragColor.a < 0.05 || brightness < 0.55) {
    discard;
  }
}


===== Filename: src/js/glsl/main.vert =====

precision highp float;

uniform float uPointSize;
uniform float uProgress;
uniform float uTime;
uniform sampler2D uTouch;
uniform float uNbLines;
uniform float uNbColumns;
uniform float uScaleHeightPointSize;

attribute vec3 initPosition;
attribute float randoms;
attribute float visibility;

varying vec2 vTexCoords;
varying float vAlpha;

uniform sampler2D uSpriteSheet;    // Active Sprite Sheet
uniform vec2 uTexOffset;           // UV Offset to Select Current Frame
uniform float uDisplacementScale;  // Intensity of Z-Axis Displacement
uniform float uSpriteCols;         // Number of columns in the sprite sheet
uniform float uSpriteRows;         // Number of rows in the sprite sheet
uniform float uFrameIndex;         // Current frame index
uniform float uDisplacementBlend;  // Blend displacement effect
uniform float uDispersion;
uniform float uDistortionFrequency;
uniform float uDistortionAmplitude;
uniform float uRandomSeed;
uniform float uTotalFrames;

// Function to generate a pseudo-random value
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

// Noise functions (snoise, etc.) remain unchanged

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r) {
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v) {
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;

  // Permutations
  i = mod289(i);
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients: 7x7 points over a square, mapped onto an octahedron.
  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857;
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  // Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}

void main() {
  // Calculate normalized UVs based on particle position within the grid
  float normalizedX = (position.x + (uNbLines / 2.0)) / float(uNbLines);
  float normalizedY = (position.y + (uNbColumns / 2.0)) / float(uNbColumns);
  vTexCoords = vec2(normalizedX, normalizedY);

  // Calculate frame index and UV offset
  float framesPerSheet = float(uTotalFrames);
  float frameIndex = floor(uFrameIndex);
  
  // Calculate Column and Row for Current Frame
  float frameCol = mod(frameIndex, uSpriteCols);
  float frameRow = floor(frameIndex / uSpriteCols);

  float frameWidth = 1.0 / uSpriteCols;
  float frameHeight = 1.0 / uSpriteRows;

  vec2 frameUVOffset = vec2(frameCol * frameWidth, frameRow * frameHeight);
  vec2 spriteUV = frameUVOffset + vTexCoords * vec2(frameWidth, frameHeight);

  // Sample sprite sheet
  vec4 spriteData = texture2D(uSpriteSheet, spriteUV);
  float brightness = spriteData.r;

  // Simplified displacement calculation
  float displacement = mix(initPosition.z, brightness * uDisplacementScale, uDisplacementBlend);

  // Simplified position calculation
  vec3 transformed = mix(position, initPosition, uDispersion);
  transformed.z += displacement;

  // Reduce noise effect
  vec3 noiseInput = vec3(transformed.xy * 0.02, uTime * 0.02);
  transformed += vec3(
    snoise(noiseInput),
    snoise(noiseInput + 100.0),
    snoise(noiseInput + 200.0)
  ) * 0.1;

  vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
  gl_Position = projectionMatrix * mvPosition;

  // Increase point size
  gl_PointSize = (uPointSize * 2.0 + randoms * 0.2) * (uScaleHeightPointSize / -mvPosition.z) * visibility;

  // Set the alpha to 0 for invisible particles
  vAlpha = visibility;
}


===== Filename: src/scss/style.scss =====

// ===== Filename: src/scss/style.scss =====

@import 'imports/index';
@import 'includes/reset';
@import 'includes/root';
@import 'components/scene';
@import 'components/title';
@import 'components/footer';

body {
    margin: 0;
    overflow: hidden;
    background-color: #111111;
    color: #fff;
    font-family: 'VT323', monospace;
}

// Container for the title, fixed at the top with a gradient background
.title-container {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    padding: 20px;
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
    z-index: 10;
}

// Styling for the title text
.title {
    font-size: 4rem;
    font-weight: 700;
    color: #ffffff;
    text-shadow: 0 0 10px rgba(165, 199, 246, 0.5);
    margin: 0;
    text-align: center;
    letter-spacing: 2px;
    transform: perspective(500px) rotateX(10deg);
    animation: titlePulse 2s infinite alternate;
}

// Keyframes for the title's pulsing animation
@keyframes titlePulse {
    from {
        text-shadow: 0 0 10px rgba(165, 199, 246, 0.5);
    }

    to {
        text-shadow: 0 0 20px rgba(165, 199, 246, 0.8), 0 0 30px rgba(165, 199, 246, 0.6);
    }
}

// Container for swipe loaders, covering the entire viewport
.swipeloaders {
    position: relative;
    width: 100vw;
    height: 100vh;
    z-index: 100;
    overflow: hidden;
    pointer-events: none;
}

// Loader with a black background, fixed and centered
.homeloaderblack {
    cursor: none;
    position: fixed;
    z-index: 101;
    justify-content: space-around;
    align-items: center;
    width: 100vw;
    height: 100vh;
    background-color: transparent;
    display: flex;
    pointer-events: none;
}

// Text styling within the loader
.text {
    position: relative;
    color: #ffffff;
    margin: 0;
    flex: auto;
    user-select: none;
    font-size: 1.0rem;
    font-weight: bold;
}

// Styling for target and cursor elements
.target,
.cursor {
    border-radius: 100%;
    width: 0px;
    height: 0px;
    background-color: rgba(9, 154, 183, 0.5); // Solid color with transparency
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    position: absolute;
    top: 50%;
    left: 10%;
    -webkit-transform: translate(-50%, -50%) rotate(0deg);
    transform: translate(-50%, -50%) rotate(0deg);
    pointer-events: auto;
    z-index: 102;
}

// Specific styling for target elements
.target {
    border-radius: 0;
    position: relative;
    width: 80px;
    height: 80px;
    background: none; // Make the box invisible
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    margin: 0 50px;
    pointer-events: auto;
    cursor: pointer;
    top: 40%;
    z-index: 103;
}

// Scene container, fixed and covering the entire viewport
.scene {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    background: transparent;
}

// Section styling for modal-like elements
section {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    color: #ffffff;
    padding: 20px;
    border-radius: 10px;
    max-width: 80%;
    max-height: 80%;
    overflow-y: auto;
    opacity: 0;
    transition: opacity 0.5s ease;
    display: none;
    z-index: 99;
}

// Active state for sections, making them visible
section.active {
    display: block;
    opacity: 1;
}

// Styling for the contact form
#contact-form {
    display: flex;
    flex-direction: column;
    gap: 10px;

    input,
    textarea {
        padding: 5px;
        border-radius: 5px;
        border: none;
    }

    button {
        padding: 10px;
        background-color: #4CAF50;
        color: #ffffff;
        border: none;
        border-radius: 5px;
        cursor: pointer;

        &:hover {
            background-color: #45a049;
        }
    }
}

// Add media query for smaller screens
@media (max-width: 768px) {
    .homeloaderblack {
        flex-direction: column;
    }

    .target {
        margin: 10px 0;
    }
}

.frame-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 2;
}

.frame-overlay img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

// Ensure the swipeloaders and homeloaderblack are above the frame
.swipeloaders,
.homeloaderblack {
    z-index: 3;
}

// Ensure sections are above the frame
section {
    z-index: 4;
}

// Ensure the title container is above the frame
.title-container {
    z-index: 5;
}


===== Filename: src/index.html =====

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <link rel="icon" type="image/x-icon" href="./img/favicon.svg" />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
  <title>3D Face Animation</title>
</head>

<body>
  <div class="title-container">
    <h1 class="title">Vang's Vital Insights</h1>
  </div>
  <div class="swipeloaders">
    <div class="homeloaderblack">
      <div class="target">
        <p class="text">Home</p>
      </div>
      <div class="target">
        <p class="text">Insights</p>
      </div>
      <div class="target">
        <p class="text">About</p>
      </div>
      <div class="target">
        <p class="text">Contact</p>
      </div>
      <div class="cursor" id="cursor"></div>
    </div>
  </div>
  <div class="frame-overlay">
    <img src="./img/frame.svg" alt="Frame" />
  </div>
  <canvas class="scene"></canvas>

  <!-- Sections for each page -->
  <section id="home" class="active">
    <h2>Home</h2>
    <p>Welcome to Vang's Vital Insights.</p>
  </section>
  <section id="insights">
    <h2>Vital Insights</h2>
    <p>Discover the power of data-driven decision making:</p>
    <ul>
      <li>Uncover hidden patterns in your business data</li>
      <li>Optimize operations with predictive analytics</li>
      <li>Transform raw data into actionable strategies</li>
      <li>Stay ahead of market trends with real-time insights</li>
    </ul>
  </section>
  <section id="about">
    <h2>About</h2>
    <p>Vang's Vital Insights is a platform dedicated to sharing valuable information and perspectives on various topics.
    </p>
  </section>
  <section id="contact">
    <h2>Contact</h2>
    <form id="contact-form">
      <label for="email">Email:</label>
      <input type="email" id="email" required>
      <label for="message">Message:</label>
      <textarea id="message" required></textarea>
      <button type="submit">Send</button>
    </form>
  </section>

  <!-- Load GSAP and Draggable before main.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/Draggable.min.js"></script>
  <script type="module" src="./main.js"></script>
</body>

</html>


===== Filename: src/main.js =====

// ===== Filename: src/main.js =====

import './scss/style.scss'  // Import the main SCSS file
import MainScene from './js/components/scene.js'
import { gsap } from 'gsap'
import { Draggable } from 'gsap/Draggable'

gsap.registerPlugin(Draggable)

window.addEventListener('load', () => {
    console.log('Window loaded')
    initializeApp()
})

function initializeApp() {
    console.log('Initializing app')
    const mainScene = new MainScene()
    console.log('MainScene initialized:', mainScene)

    const cursor = document.querySelector(".cursor")
    const homeloaderblack = document.querySelector(".homeloaderblack")
    const sections = document.querySelectorAll('section')
    const menuItems = document.querySelectorAll('.target')

    console.log('Cursor element:', cursor)
    console.log('Homeloaderblack element:', homeloaderblack)
    console.log('Sections:', sections)
    console.log('Menu items:', menuItems)

    let cursorPosition = { x: 0, y: 0 }
    let animationFrameId = null

    function updateCursor(e) {
        cursorPosition.x = e.clientX
        cursorPosition.y = e.clientY

        if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(animateCursor)
        }
    }

    function animateCursor() {
        animationFrameId = null

        let closestTarget = null
        let closestDistance = Infinity

        homeloaderblack.querySelectorAll('.target').forEach(target => {
            const rect = target.getBoundingClientRect()
            const targetCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            }

            const distance = Math.hypot(
                targetCenter.x - cursorPosition.x,
                targetCenter.y - cursorPosition.y
            )

            if (distance < closestDistance) {
                closestTarget = target
                closestDistance = distance
            }
        })

        if (closestTarget && closestDistance < closestTarget.getBoundingClientRect().width) {
            const rect = closestTarget.getBoundingClientRect()
            const targetCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            }

            const angle = Math.atan2(targetCenter.y - cursorPosition.y, targetCenter.x - cursorPosition.x)
            const distanceRatio = closestDistance / (rect.width / 2)

            // Damping factor to reduce movement (adjust as needed)
            const dampingFactor = 0.8

            gsap.to(cursor, {
                left: targetCenter.x - Math.cos(angle) * closestDistance * 0.5,
                top: targetCenter.y - Math.sin(angle) * closestDistance * 0.5,
                height: rect.height,
                width: rect.width,
                duration: 0.2
            })

            gsap.to(closestTarget.querySelector(".text"), {
                x: -Math.cos(angle) * closestDistance * 0.5 * distanceRatio * dampingFactor,
                y: -Math.sin(angle) * closestDistance * 0.5 * distanceRatio * dampingFactor,
                duration: 0.2
            })
        } else {
            gsap.to(cursor, {
                left: cursorPosition.x,
                top: cursorPosition.y,
                height: 12,
                width: 12,
                duration: 0.2
            })

            homeloaderblack.querySelectorAll('.target').forEach(target => {
                gsap.to(target.querySelector(".text"), {
                    x: 0,
                    y: 0,
                    duration: 0.2
                })
            })
        }
    }

    function handleNavigation(targetText) {
        console.log(`Navigating to: ${targetText}`)

        sections.forEach(section => {
            section.style.display = 'none'
            section.classList.remove('active')
        })

        const targetSection = document.getElementById(targetText.toLowerCase())
        if (targetSection) {
            targetSection.style.display = 'block'
            targetSection.classList.add('active')
            targetSection.style.backgroundColor = 'rgba(255, 255, 255, 0.1)' // Add visible feedback
        } else {
            console.log(`Section "${targetText}" not found.`)
        }
    }

    // Use event delegation for better performance
    homeloaderblack.addEventListener('click', (event) => {
        const target = event.target.closest('.target')
        if (target) {
            const textElement = target.querySelector('.text')
            const targetText = textElement ? textElement.textContent.trim() : null

            if (targetText) {
                console.log(`Menu item clicked: ${targetText}`)
                handleNavigation(targetText)
            } else {
                console.log('Clicked target has no .text element.')
            }
        }
    })

    // Add individual click event listeners to each menu item
    menuItems.forEach(item => {
        item.addEventListener('click', () => {
            const textElement = item.querySelector('.text')
            const targetText = textElement ? textElement.textContent.trim() : null

            if (targetText) {
                console.log(`Menu item clicked directly: ${targetText}`)
                handleNavigation(targetText)
            } else {
                console.log('Clicked menu item has no .text element.')
            }
        })
    })

    const contactForm = document.getElementById('contact-form')
    if (contactForm) {
        contactForm.addEventListener('submit', (e) => {
            e.preventDefault()
            const email = document.getElementById('email').value
            const message = document.getElementById('message').value
            console.log(`Form submitted: Email - ${email}, Message - ${message}`)
            contactForm.reset()
        })
    }

    document.addEventListener("mousemove", updateCursor, { passive: true })

    // Add a simple click event listener to the body
    document.body.addEventListener('click', (event) => {
        console.log(`Body clicked: ${event.target.tagName}`)
    })

    // Initialize the home section as active
    handleNavigation('Home')
}

