
===== Filename: src/js/components/scene.js =====

import {
  Color,
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  BufferGeometry,
  BufferAttribute,
  Points,
  ShaderMaterial,
  Raycaster,
  Vector2,
  LinearFilter,
  ClampToEdgeWrapping,
} from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import Stats from 'stats-js'
import LoaderManager from '@/js/managers/LoaderManager'
import GUI from 'lil-gui'

import vertexShader from '@/js/glsl/main.vert'
import fragmentShader from '@/js/glsl/main.frag'
import { randFloat } from 'three/src/math/MathUtils'
import gsap from 'gsap'
import TouchTexture from './TouchTexture'
import { sortPoints } from '@/js/utils/three'
import { isTouch } from '@/js/utils/isTouch'

export default class MainScene {
  canvas
  renderer
  scene
  camera
  controls
  stats
  width
  height
  guiObj = {
    uProgress: 0,
    pointSize: 1.5,
  }


  constructor() {
    this.canvas = document.querySelector('.scene')
    if (!this.canvas) {
      throw new Error('Canvas element with class "scene" not found')
    }
    this.width = window.innerWidth
    this.height = window.innerHeight

    // Create touch texture for mouse particles animation
    this.touch = new TouchTexture()

    this.init().catch(error => {
      console.error('Initialization failed:', error)
      // Optionally, display an error message to the user
    })
  }

  init = async () => {
    try {
      // Preload assets before initiating the scene
      const assets = [
        // { name: 'me', texture: './img/me.png' },
        { name: 'sprite1', texture: './img/sprite1.jpg' },
        { name: 'sprite2', texture: './img/sprite2.jpg' },
      ]

      await LoaderManager.load(assets)
      console.log('Loaded Textures:', LoaderManager.assets)

      this.setStats()
      this.setGUI()
      this.setScene()
      this.setRender()
      this.setCamera()
      this.setControls()
      this.setParticlesGrid()
      // this.setAxesHelper()
      this.setRaycaster()

      this.handleResize()

      // start RAF
      this.events()

      this.animateIn()
      this.uniforms.uProgress.value = 1.0
    } catch (error) {
      console.error('Error during initialization:', error)
      throw error // Re-throw to be caught in the constructor
    }
  }

  /**
   * Our Webgl renderer, an object that will draw everything in our canvas
   * https://threejs.org/docs/?q=rend#api/en/renderers/WebGLRenderer
   */
  setRender() {
    try {
      this.renderer = new WebGLRenderer({
        canvas: this.canvas,
        antialias: true,
      })
      this.renderer.setSize(this.width, this.height)
      this.renderer.setPixelRatio(window.devicePixelRatio || 1)
    } catch (error) {
      console.error('Error setting up WebGL renderer:', error)
      throw error
    }
  }

  /**
   * This is our scene, we'll add any object
   * https://threejs.org/docs/?q=scene#api/en/scenes/Scene
   */
  setScene() {
    this.scene = new Scene()
    // this.scene.background = new Color(0xffffff)
  }

  /**
   * Our Perspective camera, this is the point of view that we'll have
   * of our scene.
   * A perscpective camera is mimicing the human eyes so something far we'll
   * look smaller than something close
   * https://threejs.org/docs/?q=pers#api/en/cameras/PerspectiveCamera
   */
  setCamera() {
    const aspectRatio = this.width / this.height
    const fieldOfView = 60
    const nearPlane = 0.1
    const farPlane = 10000

    // set classic camera
    this.camera = new PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane)
    this.camera.position.set(0, 0, 125)
    this.camera.lookAt(0, 0, 0)

    this.scene.add(this.camera)
  }

  /**
   * Threejs controls to have controls on our scene
   * https://threejs.org/docs/?q=orbi#examples/en/controls/OrbitControls
   */
  setControls() {
    try {
      this.controls = new OrbitControls(this.camera, this.renderer.domElement)
      this.controls.enableDamping = true
      this.controls.enableRotate = true // Disable rotation to prevent interference
      this.controls.enableZoom = true   // Disable zoom if not needed
      // this.controls.autoRotate = true
      // this.controls.dampingFactor = 0.04
    } catch (error) {
      console.error('Error setting up OrbitControls:', error)
      // Optionally, you might want to continue without controls
      this.controls = null
    }
  }

  setParticlesGrid() {
    try {
      // Create a grid of particles

      // create a geometry
      const geometry = new BufferGeometry()

      const particles = []
      const initPositions = []
      const multiplier = 16
      const nbColumns = 9 * multiplier
      const nbLines = 16 * multiplier

      this.nbColumns = nbColumns
      this.nbLines = nbLines

      const halfColumn = nbColumns / 2
      const halfLines = nbLines / 2

      // for each line / column add a "particle" to the array

      for (let i = 0; i < nbLines; i++) {
        for (let y = 0; y < nbColumns; y++) {
          const point = [i, y, 0.0] // coordinates of each point

          // appear from Z
          const initPoint = [i - halfLines, y - halfColumn, randFloat(0, 500)]

          particles.push(...point) // spread the coordinates for Float32Array
          initPositions.push(...initPoint)
        }
      }

      const vertices = new Float32Array(particles)
      const initPositionsFloat = new Float32Array(initPositions)

      // Add the particles to the array as "position" and "initPosition"
      // itemSize = 3 because there are 3 values (components) per vertex
      geometry.setAttribute('position', new BufferAttribute(vertices, 3))
      geometry.setAttribute('initPosition', new BufferAttribute(initPositionsFloat, 3))

      geometry.center()
      // const material = new MeshBasicMaterial({ color: 0xff0000 })

      this.dpr = 2 // device pixel ratio
      this.uniforms = {
        uPointSize: { value: this.guiObj.pointSize },
        uNbLines: { value: nbLines },
        uNbColumns: { value: nbColumns },
        uProgress: { value: this.guiObj.uProgress },
        uTime: { value: 0.0 },
        uTouch: { value: this.touch.texture },
        uScaleHeightPointSize: { value: (this.dpr * this.height) / 2.0 },

        // Sprite sheet uniforms
        uFrameIndex: { value: 0.0 }, // float
        uSpriteCols: { value: 5.0 }, // float
        uSpriteRows: { value: 10.0 }, // float
        uTotalFrames: { value: 100.0 }, // float

        // Sprite sheet textures
        uSprite1: { value: LoaderManager.assets['sprite1'].texture }, // sampler2D
        uSprite2: { value: LoaderManager.assets['sprite2'].texture }, // sampler2D
      }

      // create a custom shaderMaterial for this geometry
      const customMaterial = new ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader,
        fragmentShader,
        transparent: true,
        depthTest: false,
        depthWrite: false,
      })
      this.mesh = new Points(geometry, customMaterial)

      this.scene.add(this.mesh)
    } catch (error) {
      console.error('Error setting up particle grid:', error)
      throw error
    }
  }

  animateIn() {
    // animate progress uniform
    gsap.fromTo(
      this.uniforms.uProgress,
      {
        value: 0,
      },
      {
        value: 1,
        duration: 2.5,
        ease: 'Power4.easeOut',
      }
    )
  }

  /**
   * Axes Helper
   * https://threejs.org/docs/?q=Axesh#api/en/helpers/AxesHelper
   */
  setAxesHelper() {
    const axesHelper = new AxesHelper(3)
    this.scene.add(axesHelper)
  }

  /**
   * Build stats to display fps
   */
  setStats() {
    try {
      this.stats = new Stats()
      this.stats.showPanel(0)
      document.body.appendChild(this.stats.dom)
    } catch (error) {
      console.error('Error setting up stats:', error)
      // Optionally continue without stats
      this.stats = null
    }
  }

  setGUI() {
    try {
      const gui = new GUI()
      gui.add(this.guiObj, 'uProgress', 0, 1).onChange(() => {
        this.uniforms.uProgress.value = this.guiObj.uProgress
      })
      // Removed texture selection GUI as frame index now controls sprite sheets
      gui.add(this.guiObj, 'pointSize', 0, 100).onChange(() => {
        this.uniforms.uPointSize.value = this.guiObj.pointSize
      })
    } catch (error) {
      console.error('Error setting up GUI:', error)
      // Optionally continue without GUI
    }
  }
  /**
   * List of events
   */
  events() {
    window.addEventListener('resize', this.handleResize, { passive: true })
    this.draw(0)
  }

  // EVENTS

  /**
   * Request animation frame function
   * This function is called 60/time per seconds with no performance issue
   * Everything that happens in the scene is drawed here
   * @param {Number} now
   */
  draw = (time) => {
    if (this.stats) this.stats.begin()

    if (this.controls) this.controls.update() // for damping

    sortPoints(this.mesh, this.camera) // sort points to avoid render order issues due to transparency

    // Update uTime
    this.uniforms.uTime.value = time * 0.001 // Convert to seconds

    this.renderer.render(this.scene, this.camera) // render scene

    this.touch.update() // update touch texture

    if (this.stats) this.stats.end()
    this.raf = window.requestAnimationFrame(this.draw)
  }

  /**
   * On resize, we need to adapt our camera based
   * on the new window width and height and the renderer
   */
  handleResize = () => {
    this.width = window.innerWidth
    this.height = window.innerHeight

    // Update camera
    this.camera.aspect = this.width / this.height
    this.camera.updateProjectionMatrix()

    this.renderer.setPixelRatio(this.dpr)
    this.renderer.setSize(this.width, this.height)

    this.uniforms.uScaleHeightPointSize.value = (this.dpr * this.height) / 2
  }

  setRaycaster() {
    this.ray = new Raycaster()
    this.mouse = new Vector2()

    // get Mouse position

    if (isTouch()) {
      window.addEventListener('touchmove', this.handleTouchMove)
    } else {
      window.addEventListener('mousemove', this.handleMouseMove)
    }
  }

  handleMouseMove = (e) => {
    const x = (e.clientX / window.innerWidth) * 2 - 1
    const y = -(e.clientY / window.innerHeight) * 2 + 1
    this.mouse.x = x
    this.mouse.y = y

    // Calculate normalized mouse X position (0 to 1)
    const normalizedX = e.clientX / window.innerWidth

    // Map to frame index (float)
    const frameIndex = normalizedX * (this.uniforms.uTotalFrames.value - 1)

    // Update the frame index uniform
    this.uniforms.uFrameIndex.value = frameIndex

    // From the mouse position, use a raycaster to know when the 2D plane is being touched
    this.ray.setFromCamera(this.mouse, this.camera)
    this.intersects = this.ray.intersectObjects([this.mesh])

    if (this.intersects.length) {
      const uv = new Vector2(0.5, 0.5)
      uv.x = this.intersects[0].point.x / this.nbLines + 0.5
      uv.y = this.intersects[0].point.y / this.nbColumns + 0.5
      this.touch.addTouch(uv)
    }
  }

  handleTouchMove = (e) => {
    // same as mouse move but for touch devices
    const x = (e.touches[0].clientX / window.innerWidth) * 2 - 1
    const y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1

    this.mouse.x = x
    this.mouse.y = y

    // Calculate normalized mouse X position (0 to 1)
    const normalizedX = e.touches[0].clientX / window.innerWidth

    // Map to frame index (float)
    const frameIndex = normalizedX * (this.uniforms.uTotalFrames.value - 1)

    // Update the frame index uniform
    this.uniforms.uFrameIndex.value = frameIndex

    // From the mouse position, use a raycaster to know when the 2D plane is being touched
    this.ray.setFromCamera(this.mouse, this.camera)
    this.intersects = this.ray.intersectObjects([this.mesh])

    if (this.intersects.length) {
      const uv = new Vector2(0.5, 0.5)
      uv.x = this.intersects[0].point.x / this.nbLines + 0.5
      uv.y = this.intersects[0].point.y / this.nbColumns + 0.5
      this.touch.addTouch(uv)
    }
  }
}


===== Filename: src/js/components/TouchTexture.js =====

import { Texture } from 'three'

function outSine(n) {
  return Math.sin((n * Math.PI) / 2);
}

export default class TouchTexture {
  constructor(options = {}) {
    this.size = options.size || 64
    this.maxAge = options.maxAge || 60
    this.radius = options.radius || 0.15
    this.trail = []
    this.canDraw = true

    this.initTexture()
  }

  initTexture() {
    // create a 2D canvas to store the information of the cursor
    this.canvas = document.createElement('canvas')
    this.canvas.width = this.canvas.height = this.size
    this.ctx = this.canvas.getContext('2d')
    this.ctx.fillStyle = 'black'
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)
    // draw black background

    // use the canvas as a texture
    this.texture = new Texture(this.canvas)

    this.canvas.id = 'touchTexture'
    this.canvas.style.width = this.canvas.style.height = `150px`
    this.canvas.style.position = 'fixed'
    this.canvas.style.top = '0'
    this.canvas.style.zIndex = '10000'

    // No need to add it to the body,
    // document.body.appendChild(this.canvas)
    this.canvas.style.display = 'none'
  }

  update() {
    this.clear()
    if (!this.canDraw) {
      return false
    }

    // age points
    this.trail.forEach((point, i) => {
      point.age++
      // remove old
      if (point.age > this.maxAge) {
        this.trail.splice(i, 1)
      }
    })

    // draw white points
    this.trail.forEach((point, i) => {
      this.drawTouch(point, i)
    })

    // update texture
    this.texture.needsUpdate = true
  }

  clear() {
    // clear canvas
    this.ctx.fillStyle = 'black'
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)
  }

  addTouch(point) {
    if (this.trail.length > 100) this.trail.shift() // Example cap
    let force = 0
    const last = this.trail[this.trail.length - 1]
    if (last) {
      const dx = last.x - point.x
      const dy = last.y - point.y
      const dd = dx * dx + dy * dy
      force = Math.min(dd * 10000, 1)
    }
    this.trail.push({ x: point.x, y: point.y, age: 0, force })
  }

  drawTouch(point) {
    // draw point based on size and age
    const pos = {
      x: point.x * this.size,
      y: (1 - point.y) * this.size,
    }

    let intensity = 1
    if (point.age < this.maxAge * 0.3) {
      intensity = outSine(point.age / (this.maxAge * 0.3), 0, 1, 1)
    } else {
      intensity = outSine(1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7), 0, 1, 1)
    }

    intensity *= point.force

    const radius = this.size * this.radius * intensity
    const grd = this.ctx.createRadialGradient(pos.x, pos.y, radius * 0.25, pos.x, pos.y, radius)
    // draw gradient white circles
    grd.addColorStop(0, `rgba(255, 255, 255, 0.35)`)
    grd.addColorStop(1, 'rgba(0, 0, 0, 0.0)')

    this.ctx.beginPath()
    this.ctx.fillStyle = grd
    this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2)
    this.ctx.fill()
    // fill canvas
  }

  reset() {
    // reset canvas
    this.trail = []
    this.canDraw = false
    this.ctx.beginPath()
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.0)'
    this.ctx.fill()
    clearTimeout(this.timeout)
    this.timeout = setTimeout(() => (this.canDraw = true), 0)
  }
}



===== Filename: src/js/glsl/main.frag =====

// Fragment Shader with Corrected UV Mapping
precision mediump float;

uniform sampler2D uSprite1;
uniform sampler2D uSprite2;
uniform float uFrameIndex;
uniform float uSpriteCols;
uniform float uSpriteRows;
uniform float uProgress;

varying vec2 vTexCoords;

// Function to create a circular opacity mask
float circle(vec2 uv, float border) {
  float radius = 0.5;
  float dist = radius - distance(uv, vec2(0.5));
  return smoothstep(0.0, border, dist);
}

void main() {
  // Total frames per sprite sheet
  float framesPerSheet = 50.0;

  // Determine current sprite sheet and next sprite sheet
  float sheetIndex = floor(uFrameIndex / framesPerSheet);
  float frameInSheet = mod(uFrameIndex, framesPerSheet);

  bool useSprite1 = sheetIndex < 1.0;

  // Calculate current and next frames within the sprite sheet
  float currentFrame = frameInSheet;
  float nextFrame = currentFrame + 1.0;

  // Clamp nextFrame to avoid overflow
  if (nextFrame >= framesPerSheet) {
    nextFrame = framesPerSheet - 1.0;
  }

  // Calculate row and column for current frame
  float frameCol = mod(currentFrame, uSpriteCols);
  float frameRow = floor(currentFrame / uSpriteCols);

  // Calculate row and column for next frame
  float nextFrameCol = mod(nextFrame, uSpriteCols);
  float nextFrameRow = floor(nextFrame / uSpriteCols);

  // Define frame dimensions and padding in UV space
  float frameWidth = 300.0 / 1510.0; // ≈0.1987
  float frameHeight = 170.0 / 1700.0; // =0.1
  float paddingX = 2.0 / 1510.0;      // ≈0.0013

  // Calculate UV offset for current and next frames
  vec2 frameUVOffset = vec2(frameCol * (frameWidth + paddingX), frameRow * frameHeight);
  vec2 nextFrameUVOffset = vec2(nextFrameCol * (frameWidth + paddingX), nextFrameRow * frameHeight);

  // Calculate UV within the frame
  vec2 uvWithinFrame = gl_PointCoord * vec2(frameWidth, frameHeight);

  // Final UV coordinates for current and next frames
  vec2 finalUVCurrent = frameUVOffset + uvWithinFrame;
  vec2 finalUVNext = nextFrameUVOffset + uvWithinFrame;

  // Calculate interpolation factor
  float interp = fract(uFrameIndex);

  // Sample textures
  vec4 colorCurrent = useSprite1 ? texture2D(uSprite1, finalUVCurrent) : texture2D(uSprite2, finalUVCurrent);
  vec4 colorNext = useSprite1 ? texture2D(uSprite1, finalUVNext) : texture2D(uSprite2, finalUVNext);

  // Blend between current and next frame
  vec4 blendedColor = mix(colorCurrent, colorNext, interp);

  // Apply the texture color
  gl_FragColor.rgb = blendedColor.rgb;

  // Discard pixels if too dark
  if (gl_FragColor.r < 0.1) {
    discard;
  }

  // Apply circle opacity and progress
  gl_FragColor.a = circle(gl_PointCoord, 0.2) * uProgress;
}


===== Filename: src/js/glsl/main.vert =====

// Vertex Shader with Z-Axis Displacement Disabled
precision mediump float;

uniform float uPointSize;
uniform float uProgress;
uniform float uTime;
uniform sampler2D uTouch;
uniform float uNbLines;
uniform float uNbColumns;
uniform float uScaleHeightPointSize;
// uniform float uWaveFrequency; // Unused, can be removed

attribute vec3 initPosition;

varying vec2 vTexCoords;

void main() {
  // Chunk of code used in Three.js
  #include <begin_vertex>

  // Appear effect
  transformed = initPosition + ((position - initPosition) * uProgress);

  // Get UVs of the plane
  vec2 vUv = transformed.xy / vec2(uNbLines, uNbColumns) - vec2(-0.5, -0.5);

  // Get Touch canvas texture
  // float touch = texture2D(uTouch, vUv).r;
  // Apply the touch canvas texture on the Z axis of the particles
  // (if touch texture is white, apply force, if black do nothing)
  // transformed.z += touch * 40.0; // Temporarily disable

  // Project vertex
  #include <project_vertex>

  // Get Texture coords for fragment shader
  vTexCoords = position.xy;

  // Final Position
  gl_PointSize = uPointSize * (uScaleHeightPointSize / -mvPosition.z);
}

