You are an expert in React, Vite, Tailwind CSS, three.js, GASP, Next UI and React three fiber.

INITIAL PROJECT ASSESSMENT
On starting a new chat or task:
1. Check for existing <currentTask> in this file.
2. If it exists, review it to understand the project context, complexity, and current state.
3. Reply back the latest update <currentTask> time stamp
  
Key Principles
  - Write concise, technical responses with accurate three.js examples.
  - Use functional, declarative programming. Avoid classes.
  - Prefer iteration and modularization over duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., isLoading).
  - Use lowercase with dashes for directories (e.g., components/auth-wizard).
  - Favor named exports for components.
  - Use the Receive an Object, Return an Object (RORO) pattern.
  
JavaScript
  - Use "function" keyword for pure functions. Omit semicolons.
  - Use TypeScript for all code. Prefer interfaces over types. Avoid enums, use maps.
  - File structure: Exported component, subcomponents, helpers, static content, types.
  - Avoid unnecessary curly braces in conditional statements.
  - For single-line statements in conditionals, omit curly braces.
  - Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething()).
  
Error Handling and Validation
    - Prioritize error handling and edge cases:
    - Handle errors and edge cases at the beginning of functions.
    - Use early returns for error conditions to avoid deeply nested if statements.
    - Place the happy path last in the function for improved readability.
    - Avoid unnecessary else statements; use if-return pattern instead.
    - Use guard clauses to handle preconditions and invalid states early.
    - Implement proper error logging and user-friendly error messages.
    - Consider using custom error types or error factories for consistent error handling.

  
React
  - Use functional components and interfaces.
  - Use declarative JSX.
  - Use function, not const, for components.
  - Use Next UI, and Tailwind CSS for components and styling.
  - Implement responsive design with Tailwind CSS.
  - Implement responsive design.
  - Place static content and interfaces at file end.
  - Use content variables for static content outside render functions.
  - Wrap client components in Suspense with fallback.
  - Use dynamic loading for non-critical components.
  - Optimize images: WebP format, size data, lazy loading.
  - Model expected errors as return values: Avoid using try/catch for expected errors in Server Actions. Use useActionState to manage these errors and return them to the client.
  - Use error boundaries for unexpected errors: Implement error boundaries using error.tsx and global-error.tsx files to handle unexpected errors and provide a fallback UI.
  - Use useActionState with react-hook-form for form validation.
  - Always throw user-friendly errors that tanStackQuery can catch and show to the user.


<currentTask> Sep 14 18:21:01

Creating the 3D Face Animation Effect.
In the provided 3JS scene, we can observe a particles, which appears on the scene (uProgress). Image is projected on to the particles. 

This guide provides a detailed breakdown of how to create a 3D face animation effect using Three.js, with an emphasis on understanding the techniques required and the steps necessary to implement it effectively. The goal is to create a visual effect where a face follows the movement of the mouse, using displacement maps, sprite sheets, and point-based geometry manipulation. Our main file is scene.js



Scene Setup  
    - Set up the basic 3D environment, including camera, renderer, and points-based geometry.
    - Ensure that the camera is positioned correctly to view the entire face.
    - Continuously render the scene using a Three.js renderer for smooth real-time updates.  

Sprite Sheet Integration  
    - Use a sprite sheet containing images of the face in different directions.
    - Ensure that each segment of the sprite sheet is aligned, symmetrical, and consistent.
    - Dynamically select the correct image from the sprite sheet based on mouse movement.
    - Leverage face symmetry by using images from only one side and mirroring them to represent the opposite direction.  

Displacement Map  
    - Use a grayscale image to control the Z-axis displacement of the vertices.
    - Ensure that bright areas push the vertices forward, creating the illusion of depth.
    - Match the displacement map to the face geometry for accurate 3D depth perception.
    - Optimize the displacement map’s resolution to balance detail and performance.  

Three.js Points and Geometry  
    - Use `THREE.Points` to render the face as a cloud of points in 3D space.
    - Create a buffer geometry with a grid of vertices that corresponds to the face image.
    - Manipulate the Z-axis of each point using the displacement map to simulate 3D depth.
    - Ensure that the points are dense enough for smooth deformations while keeping performance in mind.  

Mouse Interaction  
    - Track the mouse position using event listeners to detect the direction of movement.
    - Calculate the correct face orientation based on mouse position (X and Y coordinates).
    - Adjust the face’s direction dynamically by selecting the appropriate section of the sprite sheet.
    - Provide smooth, real-time feedback, ensuring that the face appears to follow the mouse naturally.  

UV Mapping and Texture Manipulation  
    - Adjust UV mapping coordinates to select the correct face image from the sprite sheet.
    - Dynamically update the texture coordinates based on the mouse’s movement.
    - Use texture mirroring to reduce the number of unique images needed on the sprite sheet.
    - Ensure that the transitions between face images are seamless for a smooth visual experience.  

Render and Animate  
    - Continuously render the 3D scene to keep the face animation responsive and in sync with mouse movement.
    - Smoothly transition between different face orientations as the mouse moves across the screen.
    - Ensure that the displacement map is applied in real-time, keeping the depth illusion intact.
    - Optimize the rendering loop to maintain a consistent frame rate, particularly at 60fps or higher for smooth animations.  

Additional Considerations  
    - Symmetry optimization: Use half of the face images and mirror them to reduce the number of textures.
    - Performance optimization: Use lower resolution for displacement maps and sprite sheets to maintain performance.
    - Real-time responsiveness: Prioritize smooth mouse interaction and fast texture updates to avoid lagging in the visual effect.  

Folder structure:
.
├── output.txt
├── package-lock.json
├── package.json
├── src
│   ├── index.html
│   ├── js
│   │   ├── components
│   │   ├── glsl
│   │   ├── index.js
│   │   ├── managers
│   │   └── utils
│   ├── public
│   │   └── img
│   └── scss
│       ├── components
│       ├── imports
│       ├── includes
│       └── style.scss
└── vite.config.js